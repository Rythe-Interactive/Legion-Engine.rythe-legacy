
.. _program_listing_file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_serialization_serializationUtil.hpp:

Program Listing for File serializationUtil.hpp
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_serialization_serializationUtil.hpp>` (``/home/runner/work/Legion-Engine.rythe-legacy/Legion-Engine.rythe-legacy/legion/engine/core/serialization/serializationUtil.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/platform/platform.hpp>
   
   #include <cereal/types/unordered_map.hpp>
   #include <cereal/types/memory.hpp>
   #include <cereal/types/vector.hpp>
   #include <cereal/archives/json.hpp>
   #include <cereal/archives/portable_binary.hpp>
   #include <core/filesystem/filesystem.hpp>
   
   #include <sstream>
   #include <fstream>
   #include <string>
   #include <memory>
   #include <any>
   
   
   //Some testing objects for serialization
   #pragma region TestObjects
   struct MyRecord
   {
   
       uint8_t x, y;
       float z;
       MyRecord()
       {
   
       }
   
       MyRecord(uint8_t _x, uint8_t _y, float _z)
       {
           x = _x;
           y = _y;
           z = _z;
       }
   
       template <class Archive>
       void serialize(Archive& ar)
       {
           ar(CEREAL_NVP(x), CEREAL_NVP(y), CEREAL_NVP(z));
       }
   };
   
   
   struct Records
   {
       MyRecord records[20];
   
       template <class Archive>
       void serialize(Archive& ar)
       {
           ar(CEREAL_NVP(records));
       }
   };
   #pragma endregion
   
   namespace legion::core::serialization
   {
   
       class SerializationUtil
       {
       public:
           template<class T>
           static void JSONSerialize(std::stringstream os, T serializable)
           {
               cereal::JSONOutputArchive archive(os); // Create an output archive, Output as outputing to a string stream
               archive(CEREAL_NVP(serializable)); // Read the data into the archive
           }
   
           template<class T>
           static T JSONDeserialize(std::stringstream is)
           {
               cereal::JSONInputArchive iarchive(is); // Create an input archive, Input as inputing to memory
               T t;
               iarchive(t); // Read the data from the archive
               return t;
           }
   
           template<class T>
           static void BinarySerialize(std::stringstream os, T serializable)
           {
               cereal::BinaryOutputArchive archive(os); // Create an output archive, Output as outputing to a string stream
               archive(CEREAL_NVP(serializable)); // Read the data into the archive
           }
   
           template<class T>
           static T BinaryDeserialize(std::stringstream is)
           {
               cereal::BinaryInputArchive iarchive(is);  // Create an input archive, Input as inputing to memory
               T t;
               iarchive(t); // Read the data from the archive
               return t;
           }
   
           template<class T>
           static void JSONSerialize(std::ofstream& os, T serializable)
           {
               log::debug("[CEREAL] Started Serializing");
               time::timer timer;
               cereal::JSONOutputArchive archive(os);// Create an output archive, Output as outputing to a filestream
               archive(cereal::make_nvp(typeid(T).name(), serializable)); // Read the data to the archive
               log::debug("[CEREAL] Finished Serializing in : {}s", timer.end().seconds());
           }
   
           template<class T>
           static T JSONDeserialize(std::ifstream& is)
           {
               cereal::JSONInputArchive iarchive(is);   // Create an input archive, Input as inputing to memory
               T t;
               iarchive(t); // Read the data from the archive
               return t;
           }
   
           template<class T>
           static void BinarySerialize(std::ofstream& os, T serializable)
           {
               cereal::BinaryOutputArchive archive(os);// Create an output archive, Output as outputing to a string stream
               archive(CEREAL_NVP(serializable)); // Read the data to the archive
           }
   
           template<class T>
           static T BinaryDeserialize(std::ifstream& is)
           {
               cereal::BinaryInputArchive iarchive(is);  // Create an input archive, Input as inputing to memory
               T t;
               iarchive(t); // Read the data from the archive
               return t;
           }
       };
   }
