
.. _program_listing_file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_filesystem_resource.hpp:

Program Listing for File resource.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_filesystem_resource.hpp>` (``/home/runner/work/Legion-Engine.rythe-legacy/Legion-Engine.rythe-legacy/legion/engine/core/filesystem/resource.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/types/types.hpp>       // byte_vec
   #include <core/platform/platform.hpp> // L_NODISCARD
   
   #include <string_view>                // std::string_view
   
   #include <Optick/optick.h>
   
   #include "detail/resource_meta.hpp"   //has_to_resource<T,Sig>, has_from_resource<T,Sig>
   
   
   namespace legion::core::filesystem
   {
   
   class Test {
   
   };
   
   
       class basic_resource
       {
       public:
   
           explicit basic_resource(std::nullptr_t placeholder) : m_container{}{}
   
           explicit basic_resource(byte_vec v) : m_container(std::move(v)) {
               OPTICK_EVENT();
           }
   
           explicit basic_resource(std::string_view v) : basic_resource(nullptr)
           {
               OPTICK_EVENT();
               m_container.assign(v.begin(), v.end());
           }
   
           //copy & move operations
           basic_resource(const basic_resource& other) = default;
           basic_resource(basic_resource&& other) noexcept = default;
           basic_resource& operator=(const basic_resource& other) = default;
           basic_resource& operator=(basic_resource&& other) noexcept = default;
   
           //stl operators
   
           L_NODISCARD auto begin() noexcept
           {
               return m_container.begin();
           }
           
           L_NODISCARD auto begin() const noexcept
           {
               return m_container.begin();
           }
   
           L_NODISCARD auto end() noexcept
           {
               return m_container.end();
           }
   
           L_NODISCARD auto end() const noexcept
           {
               return m_container.end();
           }
   
           L_NODISCARD auto data() noexcept
           {
               return m_container.data();
           }
   
           L_NODISCARD auto data() const noexcept
           {
               return m_container.data();
           }
   
           L_NODISCARD auto size() const noexcept
           {
               return m_container.size();
           }
   
           L_NODISCARD auto empty() const noexcept
           {
               return m_container.empty();
           }
   
           void clear() noexcept
           {
               m_container.clear();
           }
   
           L_NODISCARD byte_vec& get() noexcept
           {
               return m_container;
           }
           
           L_NODISCARD const byte_vec& get() const noexcept
           {
               return m_container;
           }
   
           basic_resource& operator=(const std::string_view& value)
           {
               m_container.assign(value.begin(),value.end());
               return *this;
           }
           
           L_NODISCARD std::string to_string() const
           {
               const char* const cstr = reinterpret_cast<const char*>(data());
               return std::string(cstr,size());
           }
   
   
           template <typename T,class... Args>
           L_NODISCARD T to(Args&&...args) const;
   
           template <class T>
           void from(const T& v);
           
       private:
           byte_vec m_container;
       };
   
       #ifndef DOXY_EXCLUDE
   
       template<typename T,
                typename C1 = std::enable_if<detail::has_to_resource<T,void(basic_resource*,const T&)>::value>>
       void to_resource(basic_resource* resource,const T& value)
       {
           OPTICK_EVENT();
           T::to_resource(resource,value);
       }
   
       template<typename T,
                typename C1 = std::enable_if<detail::has_to_resource<T,void(basic_resource*,const T&)>::value>>
       basic_resource to_resource(const T& value)
       {
           OPTICK_EVENT();
           basic_resource res(nullptr);
           T::to_resource(&res,value);
           return res;
       }
   
       template<typename T,
                typename C1 = std::enable_if<detail::has_from_resource<T,void(T*,const basic_resource&)>::value>>
       void from_resource(T* value, const basic_resource& resource)
       {
           OPTICK_EVENT();
           T::from_resource(value, resource);
       }
       
      template<typename T,
               typename C1 = std::enable_if<detail::has_from_resource<T,void(T*,const basic_resource&)>::value>,
               typename C2 = std::enable_if<std::is_default_constructible<T>::value>,
               typename C3 = std::enable_if<std::is_move_constructible<T>::value>>
       T from_resource(const basic_resource& resource)
       {
          OPTICK_EVENT();
          T value;
           T::from_resource(&value,resource);
           return std::move(value);
       }
       
      template<typename T,
               typename C1 = std::enable_if<detail::has_from_resource<T,void(T*,const basic_resource&)>::value>,
               typename C2 = std::enable_if<std::is_move_constructible<T>::value>,
               class ... Args>
       T from_resource(const basic_resource& resource,Args&&... args)
       {
          OPTICK_EVENT();
          T value(std::forward<Args>(args)...);
           T::from_resource(&value,resource);
           return std::move(value);
       }
   
   
       template <typename T,class... Args>
       L_NODISCARD T basic_resource::to(Args&&...args) const
       {
           OPTICK_EVENT();
           return std::move(from_resource<T>(*this, std::forward<Args>(args)...));
       }
   
       template <class T>
       void basic_resource::from(const T& v)
       {
           OPTICK_EVENT();
           to_resource(this,v);
       }
       namespace literals
       {
          inline basic_resource operator""_res(const char* str,size_type len)
          {
              return basic_resource(std::string_view(str,len));
          }
   
       }
   
       #endif
   }
