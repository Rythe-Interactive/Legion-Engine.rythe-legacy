
.. _program_listing_file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_physics_events_events.hpp:

Program Listing for File events.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_physics_events_events.hpp>` (``/home/runner/work/Legion-Engine.rythe-legacy/Legion-Engine.rythe-legacy/legion/engine/physics/events/events.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/events/event.hpp>
   #include <physics/data/physics_manifold.hpp>
   
   namespace legion::physics {
   
   
       template <class T>
       struct collision_event_base : public events::event<T>
       {
           collision_event_base(physics_manifold* m, float d) : manifold(m) , physics_delta(d) {}
   
           collision_event_base(const collision_event_base& other) = default;
           collision_event_base(collision_event_base&& other) noexcept = default;
           collision_event_base& operator=(const collision_event_base& other) = default;
           collision_event_base& operator=(collision_event_base&& other) noexcept = default;
   
           physics_manifold* manifold;
   
   
           L_NODISCARD std::pair<ecs::entity_handle,ecs::entity_handle> participants() const
           {
               return std::make_pair(
                   manifold->entityA,
                   manifold->entityB
               );
           }
   
           L_NODISCARD std::pair<math::vec3,math::vec3> centers() const noexcept
           {
               return std::make_pair(
                   manifold->colliderA->GetLocalCentroid(),
                   manifold->colliderB->GetLocalCentroid()
               );
           }
   
           L_NODISCARD std::pair<PhysicsCollider*,
                                PhysicsCollider*> colliders() const noexcept
           {
               return std::make_pair(manifold->colliderA, manifold->colliderB);
           }
   
           L_NODISCARD std::pair<transform,transform> transforms() const
           {
               return std::apply([](ecs::entity_handle a,ecs::entity_handle b)
               {
                   return std::make_pair(
                       transform(a.get_component_handles<transform>()),
                       transform(b.get_component_handles<transform>())
                   );
               }, participants());
           }
   
   
           float physics_delta;
   
       };
   
       struct trigger_event : public collision_event_base<trigger_event>
       {
           using collision_event_base<trigger_event>::collision_event_base;
       };
   
       struct collision_event : public collision_event_base<collision_event>
       {
           using collision_event_base<collision_event>::collision_event_base;
       };
   }
