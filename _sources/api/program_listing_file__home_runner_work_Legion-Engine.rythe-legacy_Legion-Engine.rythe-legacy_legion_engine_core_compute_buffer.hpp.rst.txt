
.. _program_listing_file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_compute_buffer.hpp:

Program Listing for File buffer.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_compute_buffer.hpp>` (``/home/runner/work/Legion-Engine.rythe-legacy/Legion-Engine.rythe-legacy/legion/engine/core/compute/buffer.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "detail/cl_include.hpp" // cl_context , cl_mem , cl_mem_flags
   #include <core/types/primitives.hpp> // byte, size_t
   
   #include <string> // string
   
   namespace legion::core::compute {
   
   
       enum class buffer_type : int
       {
           WRITE_BUFFER = 1,
           READ_BUFFER = 2,
       };
   
       inline buffer_type operator|(const buffer_type& lhs, const buffer_type& rhs)
       {
           return static_cast<buffer_type>(static_cast<int>(lhs) | static_cast<int>(rhs));
       }
   
       inline buffer_type& operator|=(buffer_type& lhs, const buffer_type& rhs)
       {
           return lhs = lhs | rhs;
       }
   
   
       class Buffer
       {
       public:
   
           Buffer(cl_context, void*, size_type, size_type, size_type, cl_mem_object_type, cl_image_format*, buffer_type, std::string);
           Buffer(cl_context, cl_uint, buffer_type, bool, std::string);
           Buffer(cl_context, cl_uint, cl_uint, cl_uint, buffer_type, std::string);
       
           Buffer(cl_context, byte*, size_type, buffer_type, std::string);
   
           Buffer(Buffer&& b) noexcept;
           Buffer(const Buffer& b);
   
           //copy assign & move assign operator
           //are deleted since the Buffer
           //refcounts
           Buffer& operator=(Buffer&&) noexcept = delete;
           Buffer& operator=(const Buffer&) = delete;
   
           void rename(const std::string& name);
   
           ~Buffer();
   
   
           bool hasName() const
           {
               return !m_name.empty();
           }
   
           bool isReadBuffer() const { return m_type == CL_MEM_READ_ONLY || m_type == CL_MEM_READ_WRITE; }
   
           bool isWriteBuffer()const { return m_type == CL_MEM_WRITE_ONLY || m_type == CL_MEM_READ_WRITE; }
           bool isValid() const { return m_data != nullptr; };
       private:
           friend class Program;
           friend class Kernel;
   
           std::string m_name;
           cl_mem m_memory_object;
           size_type* m_ref_count;
           cl_mem_flags m_type;
           byte* m_data;
           size_type m_size;
       };
   }
   
