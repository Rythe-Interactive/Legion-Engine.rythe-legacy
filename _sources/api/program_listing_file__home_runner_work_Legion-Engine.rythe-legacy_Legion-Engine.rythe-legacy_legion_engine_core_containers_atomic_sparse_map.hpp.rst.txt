
.. _program_listing_file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_containers_atomic_sparse_map.hpp:

Program Listing for File atomic_sparse_map.hpp
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_containers_atomic_sparse_map.hpp>` (``/home/runner/work/Legion-Engine.rythe-legacy/Legion-Engine.rythe-legacy/legion/engine/core/containers/atomic_sparse_map.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <vector>
   #include <unordered_map>
   #include <type_traits>
   #include <algorithm>
   #include <stdexcept>
   #include <core/async/rw_spinlock.hpp>
   #include <core/platform/platform.hpp>
   #include <core/types/primitives.hpp>
   #include <core/containers/iterator_tricks.hpp>
   
   namespace legion::core
   {
       template <typename key_type, typename value_type, template<typename...> typename dense_type = std::vector, template<typename...> typename sparse_type = std::unordered_map>
       class atomic_sparse_map
       {
       public:
           using self_type = atomic_sparse_map<key_type, value_type, dense_type, sparse_type>;
           using self_reference = self_type&;
           using self_const_reference = const self_type&;
   
           using key_reference = key_type&;
           using key_const_reference = const key_type&;
           using key_pointer = key_type*;
   
           using value_reference = value_type&;
           using value_const_reference = const value_type&;
           using value_pointer = value_type*;
   
           using sparse_container = sparse_type<key_type, size_type>;
           using dense_value_container = dense_type<value_type>;
           using dense_key_container = dense_type<key_type>;
   
           using iterator = core::key_value_pair_iterator<typename dense_key_container::iterator, typename dense_value_container::iterator>;
           using const_iterator = core::key_value_pair_iterator<typename dense_key_container::const_iterator, typename dense_value_container::const_iterator>;
   
       private:
           mutable async::rw_spinlock m_container_lock;
   
           dense_value_container m_dense_value;
           dense_key_container m_dense_key;
           sparse_container m_sparse;
   
           std::atomic<size_type> m_size = 0;
           std::atomic<size_type> m_capacity = 0;
   
       public:
           L_NODISCARD async::rw_spinlock& get_lock() const { return m_container_lock; }
           L_NODISCARD dense_value_container& values() { return m_dense_value; }
           L_NODISCARD const dense_value_container& values() const { return m_dense_value; }
   
           L_NODISCARD dense_key_container& keys() { return m_dense_key; }
           L_NODISCARD const dense_key_container& keys() const { return m_dense_key; }
   
           L_NODISCARD iterator begin()
           {
               async::readonly_guard lock(m_container_lock);
               return iterator(m_dense_key.begin(), m_dense_value.begin());
           }
           L_NODISCARD const_iterator begin() const
           {
               async::readonly_guard lock(m_container_lock);
               return const_iterator(m_dense_key.cbegin(), m_dense_value.cbegin());
           }
           L_NODISCARD const_iterator cbegin() const
           {
               async::readonly_guard lock(m_container_lock);
               return const_iterator(m_dense_key.cbegin(), m_dense_value.cbegin());
           }
   
           L_NODISCARD iterator end()
           {
               async::readonly_guard lock(m_container_lock);
               return iterator(m_dense_key.begin() + m_size, m_dense_value.begin() + m_size);
           }
           L_NODISCARD const_iterator end() const
           {
               async::readonly_guard lock(m_container_lock);
               return const_iterator(m_dense_key.cbegin() + m_size, m_dense_value.cbegin() + m_size);
           }
           L_NODISCARD const_iterator cend() const
           {
               async::readonly_guard lock(m_container_lock);
               return const_iterator(m_dense_key.cbegin() + m_size, m_dense_value.cbegin() + m_size);
           }
   
   
           L_NODISCARD inline size_type size(std::memory_order order = std::memory_order_acquire) const noexcept { return m_size.load(order); }
   
           L_NODISCARD inline size_type capacity(std::memory_order order = std::memory_order_acquire) const noexcept { return m_capacity.load(order); }
   
           L_NODISCARD size_type max_size() const noexcept { async::readonly_guard lock(m_container_lock); return m_dense_value.max_size(); }
   
           L_NODISCARD inline bool empty(std::memory_order order = std::memory_order_acquire) const noexcept { return m_size.load(order) == 0; }
   
           inline void clear(std::memory_order order = std::memory_order_release) noexcept { m_size.store(0, order); }
   
           inline void reserve(size_type size, std::memory_order loadOrder = std::memory_order_acquire, std::memory_order storeOrder = std::memory_order_release)
           {
               if (size > m_capacity.load(loadOrder))
               {
                   async::readwrite_guard lock(m_container_lock);
                   m_dense_value.resize(size);
                   m_dense_key.resize(size);
                   m_capacity.store(size, storeOrder);
               }
           }
   
   #pragma region count
   
           L_NODISCARD inline size_type count(key_const_reference key) const
           {
               return contains(key);
           }
   
           L_NODISCARD inline size_type count(key_type&& key) const
           {
               return contains(key);
           }
   #pragma endregion
   
   #pragma region contains
   
           L_NODISCARD inline bool contains(key_const_reference key)
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse[key] >= 0 && m_sparse[key] < m_size && m_dense_key[m_sparse[key]] == key;
           }
   
           L_NODISCARD inline bool contains(key_type&& key)
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse[key] >= 0 && m_sparse[key] < m_size && m_dense_key[m_sparse[key]] == key;
           }
   
           L_NODISCARD inline bool contains(key_const_reference key) const
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse.count(key) && m_sparse.at(key) >= 0 && m_sparse.at(key) < m_size && m_dense_key[m_sparse.at(key)] == key;
           }
   
           L_NODISCARD inline bool contains(key_type&& key) const
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse.count(key) && m_sparse.at(key) >= 0 && m_sparse.at(key) < m_size && m_dense_key[m_sparse.at(key)] == key;
           }
   #pragma endregion
   
   #pragma region find
   
           L_NODISCARD inline iterator find(value_const_reference val)
           {
               async::readonly_guard lock(m_container_lock);
               return std::find(begin(), end(), val);
           }
   
           L_NODISCARD inline const_iterator find(value_const_reference val) const
           {
               async::readonly_guard lock(m_container_lock);
               return std::find(begin(), end(), val);
           }
   #pragma endregion
   
   #pragma region insert
   
           inline std::pair<iterator, bool> insert(key_const_reference key, value_const_reference val, std::memory_order incrementOrder = std::memory_order_acq_rel)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = val;
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size.fetch_add(1, incrementOrder);
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   
           inline std::pair<iterator, bool> insert(key_type&& key, value_const_reference val, std::memory_order incrementOrder = std::memory_order_acq_rel)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = val;
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = std::move(key);
   
                   m_sparse[*itr_key] = m_size.fetch_add(1, incrementOrder);
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   
           inline std::pair<iterator, bool> insert(key_const_reference key, value_type&& val, std::memory_order incrementOrder = std::memory_order_acq_rel)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = val;
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size.fetch_add(1, incrementOrder);
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   
           inline std::pair<iterator, bool> insert(key_type&& key, value_type&& val, std::memory_order incrementOrder = std::memory_order_acq_rel)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = val;
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size.fetch_add(1, incrementOrder);
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
               return std::make_pair(end(), false);
           }
   #pragma endregion
   
   #pragma region emplace
   
           template<typename... Arguments>
           inline std::pair<iterator, bool> emplace(key_const_reference key, std::memory_order incrementOrder, Arguments&&... arguments)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type(arguments...);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size.fetch_add(1, incrementOrder);
   
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
   
               return std::make_pair(end(), false);
           }
   
           template<typename... Arguments>
           inline std::pair<iterator, bool> emplace(key_type&& key, std::memory_order incrementOrder, Arguments&&... arguments)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type(arguments...);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[*itr_key] = m_size.fetch_add(1, incrementOrder);
   
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
   
               return std::make_pair(end(), false);
           }
   
           template<typename... Arguments>
           inline std::pair<iterator, bool> emplace(key_const_reference key, Arguments&&... arguments)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type(arguments...);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size.fetch_add(1, std::memory_order_acq_rel);
   
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
   
               return std::make_pair(end(), false);
           }
   
           template<typename... Arguments>
           inline std::pair<iterator, bool> emplace(key_type&& key, Arguments&&... arguments)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type(arguments...);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[*itr_key] = m_size.fetch_add(1, std::memory_order_acq_rel);
   
                   return std::make_pair(iterator(itr_key, itr_value), true);
               }
   
               return std::make_pair(end(), false);
           }
   #pragma endregion
   
   #pragma region operator[]
   
           inline value_reference operator[](key_type&& key)
           {
               key_type k;
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type();
   
                   auto itr_key = m_dense_key.begin() + m_size; // Find iterator location at which to store the key.
                   *itr_key = std::move(key); // Move the key into the location.
                   k = *itr_key; // Fetch a copy of the key for reuse in the rest of the function.
                   m_sparse[k] = m_size.fetch_add(1, std::memory_order_acq_rel);
               }
               else
                   k = key;
   
               async::readonly_guard readonlyLock(m_container_lock);
   
               return m_dense_value[m_sparse[k]];
           }
   
           inline value_reference operator[](key_const_reference key)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   *itr_value = value_type();
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size.fetch_add(1, std::memory_order_acq_rel);
               }
   
               async::readonly_guard readonlyLock(m_container_lock);
   
               return m_dense_value[m_sparse[key]];
           }
   
           inline value_const_reference operator[](key_type&& key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   
           inline value_const_reference operator[](key_const_reference key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   #pragma endregion
   
   #pragma region get
   
           inline value_type get(key_type&& key)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse[key]];
           }
   
           inline value_type get(key_const_reference key)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse[key]];
           }
   
           inline value_type get(key_type&& key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   
           inline value_type get(key_const_reference key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   #pragma endregion
   
   #pragma region set
   
           inline void set(key_type&& key, value_const_reference val)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key.");
   
               async::readonly_guard lock(m_container_lock);
   
               m_dense_value[m_sparse[key]] = val;
           }
   
           inline void set(key_const_reference key, value_const_reference val)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key.");
   
               async::readonly_guard lock(m_container_lock);
   
               m_dense_value[m_sparse[key]] = val;
           }
   
           inline void set(key_type&& key, value_type&& val)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               m_dense_value[m_sparse[key]] = val;
           }
   
           inline void set(key_const_reference key, value_type&& val)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               m_dense_value[m_sparse[key]] = val;
           }
   #pragma endregion
   
           inline size_type erase(key_const_reference key)
           {
               if (contains(key))
               {
                   async::readwrite_guard lock(m_container_lock);
                   if (m_size - 1 != m_sparse[key])
                   {
                       m_dense_value[m_sparse[key]] = std::move(m_dense_value[m_size - 1]);
                       m_dense_key[m_sparse[key]] = std::move(m_dense_key[m_size - 1]);
                       m_sparse[m_dense_key[m_size - 1]] = std::move(m_sparse[key]);
                   }
                   --m_size;
                   return true;
               }
               return false;
           }
       };
   }
