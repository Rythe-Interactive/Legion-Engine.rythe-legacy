
.. _program_listing_file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_types_type_util.hpp:

Program Listing for File type_util.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine.rythe-legacy_Legion-Engine.rythe-legacy_legion_engine_core_types_type_util.hpp>` (``/home/runner/work/Legion-Engine.rythe-legacy/Legion-Engine.rythe-legacy/legion/engine/core/types/type_util.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <typeinfo>
   #include <core/types/primitives.hpp>
   #include <core/types/meta.hpp>
   #include <core/platform/platform.hpp>
   #include <core/common/string_extra.hpp>
   #include <string>
   #include <string_view>
   #include <cstring>
   
   #include <Optick/optick.h>
   
   namespace legion::core
   {
       template<typename T, typename U>
       constexpr T force_value_cast(U value)
       {
           static_assert(alignof(T) == alignof(U), "Illegal cast of unaligned types.");
           static_assert(sizeof(T) == sizeof(U), "Illegal cast of non size similar types.");
   
           return *reinterpret_cast<T*>(&value);
       }
   
       template<typename T, typename U>
       constexpr T* force_cast(const U& value)
       {
           return reinterpret_cast<T*>(&value);
       }
   
       template<typename T, typename U>
       constexpr T* force_cast(U&& value)
       {
           return reinterpret_cast<T*>(&value);
       }
   
       template<typename T, typename U>
       constexpr T* force_cast(U* value)
       {
           return reinterpret_cast<T*>(value);
       }
   
   
       // Credits to Tristeon engine by Leon and Tristan: https://github.com/Tristeon/Tristeon2D/blob/master/src/Serialization/Type.h
   #if defined(LEGION_MSVC) || defined(LEGION_CLANG_MSVC)
       namespace detail
       {
           template<typename T>
           std::string getNameOfTypeImpl()
           {
               OPTICK_EVENT();
               const std::string name = typeid(T).name();
               std::vector<std::string> vec = common::split_string_at<' '>(name);
               if (vec.size() < 2)
               {
                   return name;
               }
   
               std::string result;
               for (auto i = 1; i < vec.size(); i++)
               {
                   if (common::ends_with(vec[i], "struct"))
                       result += vec[i].substr(0, vec[i].size() - 6);
                   else if (common::ends_with(vec[i], "class"))
                       result += vec[i].substr(0, vec[i].size() - 5);
                   else
                       result += vec[i];
               }
               return result;
           }
       }
   #elif defined(LEGION_GCC)
   }
   #include <cxxabi.h>
   namespace legion::core
   {
       namespace detail
       {
           template<typename T>
           std::string getNameOfTypeImpl()
           {
               OPTICK_EVENT();
               //Demangle the typename generated by GCC
               int status;
               char* realName = abi::__cxa_demangle(typeid(T).name(), 0, 0, &status);
               std::string result = { realName };
               free(realName);
               return result;
           }
       }
   #elif defined(LEGION_CLANG_GCC)
   }
   #include <cxxabi.h>
   namespace legion::core
   {
       namespace detail
       {
           template<typename T>
           std::string getNameOfTypeImpl()
           {
               OPTICK_EVENT();
               //Demangle the typename generated by GCC
               int status;
               char* realName = __cxxabiv1::__cxa_demangle(typeid(T).name(), 0, 0, &status);
               std::string result = { realName };
               free(realName);
               return result;
           }
       }
   #endif
   
       template<typename T>
       cstring nameOfType()
       {
           OPTICK_EVENT();
           static std::string name = detail::getNameOfTypeImpl<T>();
           return name.c_str();
       }
   
       template<typename T>
       cstring nameOfType(T expr)
       {
           return nameOfType<std::decay_t<T>>();
       }
   
       template<size_type N>
       id_type nameHash(const char(&name)[N])
       {
           OPTICK_EVENT();
           id_type hash = 0xcbf29ce484222325;
           uint64 prime = 0x00000100000001b3;
           for (int i = 0; i < N - 1; i++)
           {
               hash = hash ^ static_cast<const byte>(name[i]);
               hash *= prime;
           }
   
           return hash;
       }
   
       id_type LEGION_FUNC nameHash(cstring name);
   
       id_type LEGION_FUNC nameHash(const std::string& name);
   
       id_type LEGION_FUNC nameHash(const std::string_view& name);
   
       namespace detail
       {
           template<typename T>
           id_type typeHashImpl()
           {
               OPTICK_EVENT();
               id_type hash = 0xcbf29ce484222325;
               uint64 prime = 0x00000100000001b3;
               cstring name = nameOfType<T>();
               while (*name != '\0')
               {
                   hash = hash ^ (byte)*name;
                   hash *= prime;
                   name++;
               }
               return hash;
           }
       }
   
       template<typename T>
       id_type typeHash()
       {
           OPTICK_EVENT();
           static id_type hash = detail::typeHashImpl<T>();
           return hash;
       }
   
       template<typename T>
       id_type typeHash(T expr)
       {
           OPTICK_EVENT();
           return typeHash<std::decay_t<T>>();
       }
   
       template<typename Iterator>
       void appendBinaryData(Iterator first, Iterator last, byte_vec& data);
   
       template<typename T>
       void appendBinaryData(T* value, byte_vec& data)
       {
           OPTICK_EVENT();
           if constexpr (has_resize<std::remove_const_t<T>, void(const std::size_t)>::value)
           {
               auto first = value->begin();
               auto last = value->end();
   
               uint64 arrSize = std::distance(first, last) * sizeof(typename decltype(first)::value_type);
   
               for (int i = 0; i < sizeof(uint64); i++)
                   data.push_back(reinterpret_cast<const byte*>(&arrSize)[i]);
   
               for (auto it = first; it != last; ++it)
                   appendBinaryData(&*it, data);
           }
           else
           {
               for (int i = 0; i < sizeof(T); i++)
                   data.push_back(reinterpret_cast<const byte*>(value)[i]);
           }
       }
   
       template<typename Iterator>
       void appendBinaryData(Iterator first, Iterator last, byte_vec& data)
       {
           OPTICK_EVENT();
           uint64 arrSize = std::distance(first, last) * sizeof(typename Iterator::value_type);
           appendBinaryData(&arrSize, data);
   
           for (Iterator it = first; it != last; ++it)
               appendBinaryData(&*it, data); // dereference iterator to get reference, then get the address to get a pointer.
       }
   
       template<typename T>
       void retrieveBinaryData(T& value, byte_vec::const_iterator& start);
   
       template<typename Iterator>
       void retrieveBinaryData(Iterator first, Iterator last, byte_vec::const_iterator& start);
   
       template<typename T>
       uint64 retrieveArraySize(byte_vec::const_iterator start)
       {
           OPTICK_EVENT();
           uint64 arrSize;
           retrieveBinaryData(arrSize, start);
           if (arrSize % sizeof(T) == 0)
               return arrSize / sizeof(T);
           return 0;
       }
   
       template<typename T>
       void retrieveBinaryData(T& value, byte_vec::const_iterator& start)
       {
           OPTICK_EVENT();
           if constexpr (has_resize<T, void(std::size_t)>::value)
           {
               uint64 arrSize = retrieveArraySize<typename T::value_type>(start);
               value.resize(arrSize);
   
               retrieveBinaryData(value.begin(), value.end(), start);
           }
           else
           {
               memcpy(&value, &*start, sizeof(T));
   
               start += sizeof(T);
           }
       }
   
       template<typename Iterator>
       void retrieveBinaryData(Iterator first, Iterator last, byte_vec::const_iterator& start)
       {
           OPTICK_EVENT();
           uint64 arrSize;
           retrieveBinaryData(arrSize, start);
   
           uint64 dist = std::distance(first, last) * sizeof(typename Iterator::value_type);
           if (dist > arrSize)
               dist = arrSize;
   
           Iterator valueIt = first;
   
           for (byte_vec::const_iterator it = start; it != (start + dist); ++valueIt)
           {
               retrieveBinaryData(*valueIt, it);
           }
   
           start += arrSize;
       }
   
   }
